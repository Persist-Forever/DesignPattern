# 设计模式

## 1 基本介绍

​		设计模式（Design pattern） 是解决软件开发某些特定问题而提出的一些解决方案也可以理解成解决问题的一些思路。通过设计模式可以帮助我们增强代码的可重用性、可扩充性、 可维护性、灵活性好。我们使用设计模式最终的目的是实现代码的高内聚和低耦合。

## 2 设计原则

### 2.1 单一职责原则

一个类只负责一件事，内聚；

优点：以降低类的复杂程度、可以提高类的可读性和维护性、降低因为业务修改带来的风险。

### 2.2 开放封闭原则

软件实体(类、模块、函数)对扩张开放，对修改封闭。

### 2.3 依赖倒转原则

依赖于抽象（接口），不依赖于具体的实现（类），也就是针对==接口编程==。

高层模块不应该依赖底层模块，两个都应该依赖抽象。

抽象不应该依赖细节，细节应该依赖抽象。

```mermaid
graph TB;
高层业务逻辑-->抽象层1
高层业务逻辑-->抽象层2
高层业务逻辑-->抽象层3
实现层1 ---> 抽象层1
实现层2 ---> 抽象层2
实现层3 ---> 抽象层3
```





### 2.4 里氏替换原则

==子类型必须能够替换掉它们的父类型==，一个软件实体如果使用的是一个父类的话，那么一定适用于其子类，而且它察觉不出父类对象和子类对象的区别。也就是说，在软件里面，把**父类都替换成它的子类，程序的行为没有变化**。

**只有当子类可以替换掉父类，软件单元的功能不能受到影响时，父类才能真正被复用，而子类也能够在父类的基础上增加新的功能。**

### 2.5 迪米特法则

又名最小知道原则。

 一个对象应该对其他对象保持最少的了解，类与类关系越密切，耦合度越大。

### 2.6 接口隔离原则

**将臃肿庞大的接口拆分成更小和更具体的接口**。要为各个类建立它们需要的专用接口，而不要试图去建立一个庞大的接口供所有一类它的类去调用。

### 2.7 合成复用原则

​	找出应用中可能需要变化之处，把它们独立出来，不要和那些不需要变化的代码混在一起。

​	针对接口编程，而不是针对实现编程。

​	为了交互对象之间的松耦合设计而努力， 少用继承。

## 3 设计模式的分类


总体来说设计模式分为三大类：

创建型模式，共五种：工厂方法模式、抽象工厂模式、单例模式、建造者模式、原型模式。

结构型模式，共七种：适配器模式、装饰器模式、代理模式、外观模式、桥接模式、组合模式、享元模式。

行为型模式，共十一种：策略模式、模板方法模式、观察者模式、迭代子模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式。

## 4 创建型



## 5 结构型

### 5.1 组合模式

将对象组合成树形结构以表示“部分与整体”的层次结构。组合模式使得用户对单个对象和组合对象的实际用具有一致性。

```mermaid
classDiagram
Component <| -- Composite
Component <| -- Leaf
Composite o-- Component
Component : +Add(Component)
Component : +Del(Component)
Component : +Display()
Component : +Deal()
class Composite {
	+Vector<Component> com
	+Add(Component)
	+Del(Component)
	+Display()
	+Deal()
}
class Leaf {
	+Display()
	+Deal()
}


公司 <| -- 子公司
公司 <| -- 财务部
公司 <| --  人力资源部
子公司 o-- 公司
公司 : +Add(公司)
公司 : +Del(公司)
公司 : +Display()
公司 : +Deal()
class 子公司 {
	+Vector<公司> com
	+Add(公司)
	+Del(公司)
	+Display()
	+Deal()
}
class 人力资源部 {
	+Display()
	+Deal()
}
class 财务部 {
	+Display()
	+Deal()
}

```



​	当你发现需求中体现部分与整体层次的结构时，以及你希望用户可以忽略组合对象与单个对象的不同，统一地使用组合结构中的所有对象时，就应该考虑组合模式了。==组合模式让客户可以一致地使用组合结构和单个对象。==

组合模式主要用来处理树形结构的数据，如果要表达的数据不是树形结构，就不太适合组合模式。

- 样例：

```mermaid
graph TD;
	东莞总公司-->东莞总部hr;
	东莞总公司-->东莞总部财务;
	东莞总公司-->厚街子公司;
	东莞总公司-->松山湖子公司;
	松山湖子公司-->松山湖子公司财务;
	松山湖子公司-->松山湖子公司HR;
```

- 代码实现

  ```c++
  /**
  	公司管理系统抽象接口
  */
  #pragma once
  #include <string>
  #include <map>
  #include <memory>
  class Company {
  public:
  	Company(uint32_t id, std::string name) : m_id(id), m_name(name) {}
  	virtual void Add(uint32_t id, std::unique_ptr<Company>&& company) {};
  	virtual void Del(uint32_t id) {};
  	virtual void Display() {};
  	virtual void Doduty() {};
  protected:
  	uint32_t m_id;
  	std::string m_name;
  	//std::map<uint32_t, std::unique_ptr<Company>> m_company;
  };
  ```

  ```c++
  /**
  	xxx子公司
  */
  #pragma once
  #include "Company.h"
  
  class DGCompany : public Company {
  public:
  	DGCompany(uint32_t id, std::string name) : Company(id, name) {}
  	virtual void Add(uint32_t id, std::unique_ptr<Company>&& company);
  	virtual void Del(uint32_t id);
  	virtual void Display();
  	void Doduty();
  private:
  	std::map<uint32_t, std::unique_ptr<Company>> m_company;
  };
  #include "DGCompany.h"
  #include <iostream>
  #include  <utility>
  
  void DGCompany::Add(uint32_t id, std::unique_ptr<Company>&& company)
  {
  	m_company.emplace(std::make_pair(id, std::forward<std::unique_ptr<Company>>(company)));
  }
  
  void DGCompany::Del(uint32_t id)
  {
  	m_company.erase(id);
  }
  
  void DGCompany::Display()
  {
  	std::cout << "Company id : " << m_id << "  name : " << m_name << std::endl;
  	for (auto& company : m_company) {
  		(company.second)->Display();
  	}
  }
  
  void DGCompany::Doduty()
  {
  	std::cout << "DGCompany work ..." << std::endl;
  	for (auto& company : m_company) {
  		(company.second)->Doduty();
  	}
  }
  ```

  ```c++
  /*
  	HR 部门
  */
  #pragma once
  #include "Company.h"
  
  class HrDept : public Company {
  public:
  	HrDept(uint32_t id, std::string name) : Company(id, name) {}
  	void Doduty();
  	void Display();
  };
  #include "HrDept.h"
  #include <iostream>
  
  void HrDept::Doduty()
  {
  	std::cout << "HrDept work ..." << std::endl;
  }
  
  void HrDept::Display()
  {
  	std::cout << "Company id : " << m_id << "  name : " << m_name << std::endl;
  }
  ```

  ```c++
  /**
  	财务部
  */
  #pragma once
  #include "Company.h"
  
  class FinanceDept : public Company {
  public:
  	FinanceDept(uint32_t id, std::string name) : Company(id, name) {}
  	void Display();
  	void Doduty();
  };
  #include "FinanceDept.h"
  #include <iostream>
  
  void FinanceDept::Doduty()
  {
  	std::cout << "FinanceDept work ..." << std::endl;
  }
  
  void FinanceDept::Display()
  {
  	std::cout << "Company id : " << m_id << "  name : " << m_name << std::endl;
  }
  ```

### 5.2 适配器模式

- 概念

适配器模式将一个类的接口转换成客户希望的另外一个接口。Adapter模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。

适配器模式主要应用于希望复用一些现存的类，但是接口又与复用环境不一致的情况。

- 类结构图

```mermaid
classDiagram
Target <| -- Adapter
Adaptee <-- Adapter
Target:+Request()
class Adapter {
	+Request()
}
class Adaptee {
	+SpecialRequest()
}

MainLandPlug <| -- PlugAdapter
HongkongPlug <-- PlugAdapter
MainLandPlug:+MainLandTreePlug()
class PlugAdapter {
	+MainLandTreePlug()
}
class HongkongPlug {
	+HongKongTreePlug()
}
```

1. Target:客户所期待的接口，目标可以时具体的或者抽象的类，也可以是接口

2. Adapter:通过在内部包装一个Adaptee对象，把源皆苦转换成目标接口

3. Adaptee：需要适配的类

适配器实现有三大类：类适配器，对象适配器，接口适配器。

1. 类适配器：通过多重继承目标接口和被适配者类方式来实现适配
2. 对象适配器：对象适配器和类适配器使用了不同的方法实现适配，对象适配器使用组合，类适配器使用继承。
3. 接口适配器：当不需要全部实现接口提供的方法时，可先设计一个抽象类实现接口，并为该接口中每个方法提供一个默认实现（空方法），那么该抽象类的子类可有选择地覆盖父类的某些方法来实现需求，它适用于一个接口不想使用其所有的方法的情况。

- 举例 ：使用 对象适配器

插头转换案例，香港的三座插头和大陆的三座插头不同，如果买了香港的电器，需要买相应的转换插头。

```c++
/**
* 
	期望接口 : 大陆插头
*/
#pragma once

class MainLandPlug {
public:
	virtual void MainLandTreePlug() = 0; // 大陆三座插头
};

/**
	插头转换适配器
*/
#pragma once
#include "MainLandPlug.h"
#include <memory>
#include "HongkongPlug.h"
class PlugAdapter : public MainLandPlug {
public:
	PlugAdapter();
	virtual ~PlugAdapter() = default;
	void MainLandTreePlug();
private:
	std::unique_ptr<HongkongPlug> m_adpter{ nullptr };
};

/**
	需要适配的类：香港插头
*/
#pragma once
class HongkongPlug {
public:
	void HongkongTreePlug();
};
```

```c++
void HongkongPlug::HongkongTreePlug()
{
	std::cout << "香港三座插头" << std::endl;
}

PlugAdapter::PlugAdapter()
{
	m_adpter = std::make_unique<HongkongPlug>();
}

void PlugAdapter::MainLandTreePlug()
{
	if (m_adpter == nullptr) {
		std::cout << "adpter is nullptr ... " << std::endl;
		return;
	}
	m_adpter->HongkongTreePlug();
}

int main() {
	auto ptr = std::make_unique<PlugAdapter>();
	ptr->MainLandTreePlug();
	return 0;
}
```



## 6 行为型

